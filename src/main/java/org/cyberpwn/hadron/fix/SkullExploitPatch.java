package org.cyberpwn.hadron.fix;

import java.util.ArrayList;
import java.util.List;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.inventory.ItemStack;
import org.phantomapi.construct.Controllable;
import org.phantomapi.construct.Controller;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.wrappers.nbt.NbtBase;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;

public class SkullExploitPatch extends Controller
{
	public ItemPatcher ip;
	public ChunkPatcher cp;
	
	public SkullExploitPatch(Controllable parentController)
	{
		super(parentController);
		
		ip = new ItemPatcher(this, this);
		cp = new ChunkPatcher(this, this);
		
		register(ip);
		register(cp);
	}
	
	public void onStart()
	{
		ProtocolLibrary.getProtocolManager().addPacketListener(new SkullExploitListener(this));
	}
	
	public boolean isExploit(ItemStack stack)
	{
		try
		{
			if(stack == null)
			{
				return false;
			}
			
			if(stack.getType() == Material.SKULL || stack.getType() == Material.SKULL_ITEM)
			{
				if(stack.getDurability() == 3)
				{
					NbtCompound tag = (NbtCompound) NbtFactory.fromItemTag(stack);
					if(isExploit(tag))
					{
						return true;
					}
				}
			}
		}
		catch(Exception e)
		{

		}
		
		return false;
	}
	
	@SuppressWarnings("rawtypes")
	public boolean isExploit(NbtCompound root)
	{
		if(root.containsKey("SkullOwner"))
		{
			NbtCompound skullOwner = root.getCompound("SkullOwner");
			if(skullOwner.containsKey("Properties"))
			{
				NbtCompound properties = skullOwner.getCompound("Properties");
				if(properties.containsKey("textures"))
				{
					NbtList<NbtBase> textures = properties.getList("textures");
					for(NbtBase texture : textures.asCollection())
					{
						if(texture instanceof NbtCompound)
						{
							if(!((NbtCompound) texture).containsKey("Signature"))
							{
								if(((NbtCompound) texture).containsKey("Value"))
								{
									if(((NbtCompound) texture).getString("Value").trim().length() > 0)
									{
										return false;
									}
								}
								
								root.remove("SkullOwner");
								
								return true;
							}
						}
					}
				}
			}
		}

		if(root.containsKey("Owner"))
		{
			NbtCompound skullOwner = root.getCompound("Owner");
			if(skullOwner.containsKey("Properties"))
			{
				NbtCompound properties = skullOwner.getCompound("Properties");
				if(properties.containsKey("textures"))
				{
					NbtList<NbtBase> textures = properties.getList("textures");
					for(NbtBase texture : textures.asCollection())
					{
						if(texture instanceof NbtCompound)
						{
							if(!((NbtCompound) texture).containsKey("Signature"))
							{
								if(((NbtCompound) texture).containsKey("Value"))
								{
									if(((NbtCompound) texture).getString("Value").trim().length() > 0)
									{
										return false;
									}
								}
								
								root.remove("Owner");
								return true;
							}
						}
					}
				}
			}
		}
		return false;
	}
	
	public void cleanChunk(Chunk chunk)
	{
		List<Block> heads = new ArrayList<>();
		
		for(BlockState state : chunk.getTileEntities())
		{
			if(state != null && (state.getType() == Material.SKULL || state.getType() == Material.SKULL_ITEM))
			{
				heads.add(state.getBlock());
			}
		}
		
		for(Block head : heads)
		{
			try
			{
				NbtCompound root = NbtFactory.readBlockState(head);
				
				if(isExploit(root))
				{
					head.setType(Material.AIR);
				}
			}
			catch(Exception e)
			{
				
			}
		}
	}

	@Override
	public void onStop()
	{
		
	}
}
